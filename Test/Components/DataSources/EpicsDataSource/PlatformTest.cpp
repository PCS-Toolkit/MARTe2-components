/**
 * @file PlatformTest.cpp
 * @brief Source file for class PlatformTest
 * @date 31/01/2017
 * @author Ivan Herrero
 *
 * @copyright Copyright 2015 F4E | European Joint Undertaking for ITER and
 * the Development of Fusion Energy ('Fusion for Energy').
 * Licensed under the EUPL, Version 1.1 or - as soon they will be approved
 * by the European Commission - subsequent versions of the EUPL (the "Licence")
 * You may not use this work except in compliance with the Licence.
 * You may obtain a copy of the Licence at: http://ec.europa.eu/idabc/eupl
 *
 * @warning Unless required by applicable law or agreed to in writing,
 * software distributed under the Licence is distributed on an "AS IS"
 * basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the Licence permissions and limitations under the Licence.

 * @details This source file contains the definition of all the methods for
 * the class PlatformTest (public, protected, and private). Be aware that some
 * methods, such as those inline could be defined on the header file, instead.
 */

#define DLL_API

/*---------------------------------------------------------------------------*/
/*                         Standard header includes                          */
/*---------------------------------------------------------------------------*/

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <unistd.h>
#include <wait.h>

/*---------------------------------------------------------------------------*/
/*                         Project header includes                           */
/*---------------------------------------------------------------------------*/

#include "Platform.h"
#include "PlatformTest.h"

/*---------------------------------------------------------------------------*/
/*                           Static definitions                              */
/*---------------------------------------------------------------------------*/

struct ShmData {
	pid_t pid;
	bool ok;
	char token[];
};

struct ShmMapping {
	size_t size;
	char bytes[];
};

/* Random numbers generated by https://www.random.org/bytes/ */
//static char NUMBERS[50] = {142, 201, 221, 157, 129, 94, 136, 210, 25, 76, 7, 24, 255, 63, 249, 197, 201, 62, 239, 6, 152, 39, 252, 155, 176, 122, 67, 27, 136, 192, 152, 252,122, 222, 168, 203, 53, 14, 228, 74, 42, 52, 225, 188, 107, 123, 246, 186, 179, 7};
static char TOKEN[] = "The quick brown fox jumps over the lazy dog";
static char RTOKEN[] = "god yzal eht revo spmuj xof nworb kciuq ehT";
static const size_t TOKENLEN = std::strlen(TOKEN);

static bool MasterProcessPrologue(void*& shm, const char* const name, const char* const fullname) {

	static const size_t DATASIZE = (sizeof(ShmData) + TOKENLEN);
	static unsigned int SHMSIZE = (sizeof(ShmMapping) + DATASIZE);

	bool ok = false;

	//Create an SHM and get a raw pointer to it:
	shm = Platform::MakeShm(name, SHMSIZE);

	ok = (shm != NULL);
	ok &= (access(fullname, R_OK | W_OK) == 0);

	if (ok) {
		ShmMapping* map = NULL;
		//Map a typed pointer to SHM:
		map = reinterpret_cast<ShmMapping*>(shm);
		ok &= (map->size == SHMSIZE);
		printf("Size==%zu\n", map->size);

		if (ok) {
			ShmData* data = NULL;

			//Map a typed pointer to data:
			data = reinterpret_cast<ShmData*>(map->bytes);

			//debug token
			for (unsigned int i = 0; i < TOKENLEN; i++) {
				printf("map->data.bytes[%u]==%c\n", i, data->token[i]);
			}

			//Check default token:
			for (unsigned int i = 0; i < TOKENLEN; i++) {
				ok &= (data->token[i] == 72);
			}

			//Write original token:
			for (unsigned int i = 0; i < TOKENLEN; i++) {
				data->token[i] = TOKEN[i];
			}

			//Check original token:
			for (unsigned int i = 0; i < TOKENLEN; i++) {
				ok &= (data->token[i] == TOKEN[i]);
			}
		}
	}
	return ok;
}

static bool MasterProcessEpilogue(void* shm, const char* const name, const char* const fullname, pid_t pid) {

	static const size_t DATASIZE = (sizeof(ShmData) + TOKENLEN);
	static unsigned int SHMSIZE = (sizeof(ShmMapping) + DATASIZE);

	bool ok = false;

	ok = (shm != NULL);

	if (ok) {
		ShmMapping* map = NULL;
		//Map a typed pointer to SHM:
		map = reinterpret_cast<ShmMapping*>(shm);
		ok &= (map->size == SHMSIZE);
		printf("Size==%zu\n", map->size);

		if (ok) {
			ShmData* data = NULL;
			//Map a typed pointer to data:
			data = reinterpret_cast<ShmData*>(map->bytes);
			//Check response token:
			for (unsigned int i = 0; i < TOKENLEN; i++) {
				ok &= (data->token[i] == RTOKEN[i]);
			}
			//check child's pid
			printf("child's pid == %i\n", data->pid);
			ok &= (data->pid == pid);
			//check child's ok
			printf("child's ok == %i\n", data->ok);
			ok &= (data->ok == true);

			Platform::DettachShm(shm, map->size);

			Platform::DestroyShm(name);
			ok &= (access(fullname, R_OK | W_OK) == -1);
		}
	}

	return ok;
}

static void SlaveProcess(const char* const name, const char* const fullname) {

	static const size_t DATASIZE = (sizeof(ShmData) + TOKENLEN);
	static unsigned int SHMSIZE = (sizeof(ShmMapping) + DATASIZE);

	bool ok = false;
	printf("Hello from the child process! My pid is %i\n", getpid());
	void* shm = NULL;
	//wait until shm ready
	while (access(fullname, F_OK) == -1) {
	}
//	... perhaps not initialized, yet???

	//Join an SHM and get a raw pointer to it:
	shm = Platform::JoinShm(name);
	ok = (shm != NULL);

	if (ok) {
		ShmMapping* map = NULL;
		//Map a typed pointer to SHM:
		map = reinterpret_cast<ShmMapping*>(shm);
		ok &= (map->size == SHMSIZE);
		if (ok) {
			ShmData* data = NULL;
			//Map a typed pointer to data:
			data = reinterpret_cast<ShmData*>(map->bytes);
			//debug token
			for (unsigned int i = 0; i < TOKENLEN; i++) {
				printf("map->data.bytes[%u]==%c\n", i, data->token[i]);
			}
			//Check original token:
			for (unsigned int i = 0; i < TOKENLEN; i++) {
				ok &= (data->token[i] == TOKEN[i]);
			}
			//Write response token:
			for (unsigned int i = 0; i < TOKENLEN; i++) {
				data->token[i] = RTOKEN[i];
			}
			//debug token
			for (unsigned int i = 0; i < TOKENLEN; i++) {
				printf("map->data.bytes[%u]==%c\n", i, data->token[i]);
			}
			//Write PID:
			data->pid = getpid();
			//Write status
			data->ok = ok;
			//Dettach SHM:
			Platform::DettachShm(shm, map->size);
		}
	}
}


//bool TestMasterSlaveInSingleThread(const char* const shmName, const unsigned int maxTests = 100) {
//	void* shmMaster = NULL;
//	void* shmSlave = NULL;
//
//}
//
//bool TestMasterSlaveWithTwoThreads(const char* const shmName, const unsigned int maxTests = 100) {
//
//}


/*---------------------------------------------------------------------------*/
/*                           Method definitions                              */
/*---------------------------------------------------------------------------*/

bool PlatformTest::TestMakeShm() {
	static char NAME[] = "MARTe_PlatformTest_TestMakeShm";
	static char FULL_NAME[] = "/dev/shm/MARTe_PlatformTest_TestMakeShm";
	bool ok = false;

	void* shm = NULL;

	ok = MasterProcessPrologue(shm, NAME, FULL_NAME);

	pid_t pid = fork();

	if (pid == -1) {
		ok = false;
	}
	else if (pid == 0) {
		SlaveProcess(NAME, FULL_NAME);
		std::exit(EXIT_SUCCESS);
	}
	else {
		printf("Hello from the parent process! The child's pid is %i\n", pid);
		int status;
		(void)waitpid(pid, &status, 0);

		ok &= MasterProcessEpilogue(shm, NAME, FULL_NAME, pid);
	}

	return ok;
}

bool PlatformTest::TestJoinShm() {
	bool ok = false;
	return ok;
}

bool PlatformTest::TestDettachShm() {
	bool ok = false;
	return ok;
}

bool PlatformTest::TestDestroyShm() {
	bool ok = false;
	return ok;
}
